#fa.diagram(FA, main = i)
#add scores
scores  <- FA$scores
tract   <- cbind(subCat,scores)[,c("FIPS","PA1")]
tractFA <- rbind(tractFA,tract)
#this removes the uniquness for each strata
#just comented this our to try loadings
uniqnessFA <- bind_rows(uniqnessFA, FA$uniquenesses)
loadingsFA <- bind_rows(loadingsFA, FA$loadings[,1])
#add unikness (less than .5)
}
perVal <- cbind(uneek,perVar)
colnames(perVal) <- c(colNam,"Percent_Var")
#retruns percent variation explained
# and returns the FIPS and associated FA for each
uniqnessOfFA <- cbind(uneek,uniqnessFA)
colnames(uniqnessOfFA) <- c(colNam,colnames(uniqnessFA))
#retruns uniquness for each component and the strata
loadingsOfFA <- cbind(uneek,loadingsFA)
colnames(loadingsOfFA) <- c(colNam,colnames(loadingsFA))
#retruns 'loadings' for each component and the strata
return(list(percentVal = perVal,Strat_FA = tractFA, uniqness_by_var = uniqnessOfFA, loadings_by_var = loadingsOfFA))
}
Histo_By_Strat <- function(data,colNam,colOrig,colStrat){
#this makes a histogram comparing 2 columns of your choosing
# called "colOrig", and "colStrat"
#and are stratified by "colNam"
uneek <- unique(data[[colNam]])  #creates list to iterate thru
for(i in uneek){
par(mfrow = c(1,2))
subCat <- filter(data,get(colNam) == i)
#extracts the 2 colums you wanted histograms of
histOrg <- subCat[,colOrig]
histStrat <- subCat[,colStrat]
hist(histOrg, col=rgb(0,0,1,0.2), main = i)
hist(histStrat, col=rgb(1,0,0,0.2), add=TRUE)
#legends never die
legend('topright', c(colOrig, colStrat),
fill=c(rgb(0,0,1,0.2), rgb(1,0,0,0.2)))
pectSame <- c()
for(j in seq(from=5, to=100, by=5)){
pct <- top_Precentage(subCat,colOrig,colStrat,j)
pectSame <- rbind(pectSame,pct)
}
#this makes plot of how much overlap using counts starting at the top
top_cownt(subCat,colOrig,colStrat)
#makes scatter plor of the two columes scaled from 0->1
#and fits trend line and reference line
print(ggplot(subCat, aes(scale0_1(subCat[,colOrig]), scale0_1(subCat[,colStrat]))) +
geom_point(shape=18, color="blue") +
geom_abline(intercept = 0, slope = 1, color="green") +
geom_smooth(method=lm, se=T, color="darkred", fill="black") + #add linear trend line and Std error
ggtitle(paste(i, colOrig, "x", colStrat)) + # for the main title
xlab(colOrig) + # for the x axis label
ylab(colStrat)) # for the y axis label
}
}
top_Precentage <- function(data,colOrig,colStrat,perct){
nrw <- ceiling(nrow(data)*perct/100)
topOrg <- data %>% arrange(desc(get(colOrig)))  %>% slice(1:nrw) %>% select(FIPS)
topStr <- data %>% arrange(desc(get(colStrat))) %>% slice(1:nrw) %>% select(FIPS)
pctsame <- sum(topStr[,1] %in% topOrg[,1])/nrow(topStr)
return(data.frame(perct,pctsame))
}
top_cownt <- function(data,colOrig,colStrat){
#makes a histogram with points every 100 data points
cowntSame <- c()
samect <- c()
for(i in seq(from=5, nrow(data), by=100)){
nrw <- ceiling(i) #finds max
#selects top amount
topOrg <- data %>% arrange(desc(get(colOrig)))  %>% slice(1:nrw) %>% select(FIPS)
topStr <- data %>% arrange(desc(get(colStrat))) %>% slice(1:nrw) %>% select(FIPS)
#compares Fips from each to see the overlap
samect <- sum(topStr[,1] %in% topOrg[,1])/nrow(topStr)
cowntSame <- rbind(cowntSame,samect)
}
plot(cowntSame,type = "o", col = "#69b3a2", ylab = "Percent Shared", main = "Percent Shared")
}
#scales from 0-1
scale0_1 <- function(x){(x-min(x))/(max(x)-min(x))}
#does analysis stratified and adds it onto the end of the dataframe
strat <- "STATE" #sets strata
byLine <- FA_By_Component(cdcUnik, strat,5:21) #does analysis
withStrata <- left_join(cdcFAtract, byLine$Strat_FA, by="FIPS") #adds FA to big dataframe
#adds name of strata to the last column
names(withStrata)[length(names(withStrata))] <- paste(strat,"PA1",sep = "_")
#write uniqueness loadings to a location
#write.csv(byLine$uniqness_by_var, "C:\\Users\\Ecava\\OneDrive\\Desktop\\research\\coolstuff.csv", row.names=FALSE)
# Transform the matrix in long format
df <- melt(byLine$loadings_by_var[1:26,])
colnames(df) <- c("state", "cols", "value")
#plots out
ggplot(df, aes(x = state, y = cols, fill = value)) +
geom_tile() +
coord_fixed()
##same as above, just second half
# Transform the matrix in long format
df <- melt(byLine$loadins_by_var[27:51,])
colnames(df) <- c("state", "cols", "value")
# Transform the matrix in long format
df <- melt(byLine$loadings_by_var[1:26,])
colnames(df) <- c("state", "cols", "value")
#plots out
ggplot(df, aes(x = state, y = cols, fill = value)) +
geom_tile() +
coord_fixed()
##same as above, just second half
# Transform the matrix in long format
df <- melt(byLine$loadings_by_var[27:51,])
colnames(df) <- c("state", "cols", "value")
#plots out
ggplot(df, aes(x = state, y = cols, fill = value)) +
geom_tile() +
coord_fixed()
start.time <- Sys.time()
library(dplyr)
library(psych) #for KMO
library(GPArotation)
library(tidyverse)
library(ggplot2)
scale0_1 <- function(x){(x-min(x))/(max(x)-min(x))}
#imports data
cdc = read.csv("C:/Users/Ecava/OneDrive/Desktop/research/SVI2020_US.csv", header = TRUE)
start.time <- Sys.time()
library(dplyr)
library(psych) #for KMO
library(GPArotation)
library(tidyverse)
library(ggplot2)
scale0_1 <- function(x){(x-min(x))/(max(x)-min(x))}
#imports data
cdc = read.csv("C:/Users/Ecava/OneDrive/Desktop/research/SVI2020_US.csv", header = TRUE)
#names of cols to keep
colsKeep = c("STATE","ST_ABBR","COUNTY","FIPS", "E_TOTPOP", "EP_POV150", "EP_UNEMP", "EP_HBURD","EP_NOHSDP", "EP_UNINSUR", "EP_AGE65", "EP_AGE17",  "EP_DISABL", "EP_SNGPNT", "EP_LIMENG","EP_MINRTY", "EP_MUNIT", "EP_MOBILE","EP_CROWD",  "EP_NOVEH","EP_GROUPQ","RPL_THEMES")
#imports zip information
zips = read.csv("C:/Users/Ecava/OneDrive/Desktop/research/ZIP_TRACT_122020.csv", header = TRUE)
#combines it
cdcFul <- left_join(cdc[,colsKeep],zips[,1:3],by = c("FIPS" = "TRACT"))
#remove tracts with out populaition
cdcFul <- cdcFul[cdcFul$E_TOTPOP != 0
& cdcFul$RPL_THEMES != -999
& cdcFul$RES_RATIO != 0,]
#removes NAs
cdcFul <- na.omit(cdcFul)
#sums res ratio for each zip
cdcZip <- cdcFul %>% group_by(ZIP) %>% summarise(Freq = sum(RES_RATIO))
#finds zips with high (>80%) completeness
zip <- subset(cdcZip, Freq >= 0.8)
#checks to make sure there is enough
nrow(zip)/nrow(cdcZip)
#there is enough info so we can used just the complete ones
zip <- unique(zip$ZIP)
cdcSub <- subset(cdcFul,ZIP %in% zip)
cdcUnik <- distinct(cdcSub,FIPS,.keep_all = T)
dim(cdcUnik)
hist(cdcUnik$RPL_THEMES, breaks = 100, xlab = "CDC SVI", main = NA)
#sums res ratio for each county from the origial data set
cdcCounty <- cdcFul %>% group_by(COUNTY) %>% summarise(Freq = sum(RES_RATIO))
#finds counties with high (>80%) completeness, this can be adjusted
#this just seemed like a good level with high retension
county <- subset(cdcCounty, Freq >= 0.8)
#checks to make sure there is enough
nrow(county)/nrow(cdcCounty)
#there is enough info so we can used just the complete ones
county <- unique(county$COUNTY)
cdcSubCounty <- subset(cdcFul,COUNTY %in% county)
cdcUnikCounty <- distinct(cdcSubCounty,COUNTY,.keep_all = T)
dim(cdcUnikCounty)
#Kaiser-meyer-olkin test
cdcRedu <- cdcUnik[,5:21]
cdcCorMatrix <- cor(cdcRedu)
kmo <- KMO(r = cdcCorMatrix)
kmo$MSA #this is >> .6, can do FA
#calc and plots eigen vals
cdcFA <- fa(cdcRedu,nfactors = 5, rotate = "none")
plot(cdcFA$e.values, ylab = "Eigen vals")
#parallel <- fa.parallel(cdcRedu)
cdcFA <- fa(cdcRedu, nfactors = 1,
fm = "pa", max.iter = 100,
rotation = "promax")
# % var explained by factor
ss <- colSums(cdcFA$Structure^2)
ss/length(cdcFA$communality)
#joins scores to bigger data base
scoresFA <- cdcFA$scores
tractFA <- cbind(cdcUnik,scoresFA)[,c("FIPS","PA1")]
cdcFAtract <- left_join(cdcSub, tractFA, by="FIPS")
#adds name to last column
names(cdcFAtract)[length(names(cdcFAtract))] <- paste("FULL","PA1",sep = "_")
#pearson corelation test
cor.test(scoresFA,cdcUnik$RPL_THEMES, method = "pearson")
scoresScalled <- scale0_1(scoresFA)
#pretty picture
hist(scoresScalled,breaks = 100)
write.csv(cdcUnik, "C:\\Users\\Ecava\\OneDrive\\Desktop\\research\\cdcUnik.csv", row.names=FALSE)
write.csv(cdcFAtract, "C:\\Users\\Ecava\\OneDrive\\Desktop\\research\\cdcFAtract.csv", row.names=FALSE)
write.csv(cdcUnikCounty, "C:\\Users\\Ecava\\OneDrive\\Desktop\\research\\cdcUnikCounty.csv", row.names=FALSE)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
library(dplyr)
library(psych) #for KMO
library(GPArotation)
library(tidyverse)
library(ggplot2)
library(data.table) #for table formatting
library(formattable)
library(reshape) #for table transformation with ggplot
library(maps)
library(mapproj)
cdcUnikZip <- read.csv("C:/Users/Ecava/OneDrive/Desktop/research/cdcUnik.csv", header = TRUE)
cdcFAtract <- read.csv("C:/Users/Ecava/OneDrive/Desktop/research/cdcFAtract.csv", header = TRUE)
cdcUnikCounty <- read.csv("C:\\Users\\Ecava\\OneDrive\\Desktop\\research\\cdcUnikCounty.csv", header = TRUE)
cdcUnik <- cdcUnikZip
KMO_By_Component <- function(data,colNam){
uneek <- unique(data[[colNam]])  #creats list to iterate thru
kmo <- c()  #creates object
for(i in uneek){
# makes the sub goup for each
subCat <- filter(data,get(colNam) == i)
# extracts the cols we are looking at
subMatrix <- subCat[,5:21]
# KMO test
cdcCorMatrix <- cor(subMatrix)
kmo <- append(kmo,KMO(r = cdcCorMatrix)$MSA)
}
uneek <- cbind(uneek,kmo)
colnames(uneek) <- c(colNam,"KMO")
#returns list of groups and their KMO for examination
return(uneek)
}
FA_By_Component <- function(data,colNam, colls){
uneek <- unique(data[[colNam]])  #creats list to iterate thru
perVar <- c()  #creates objects
tractFA <- c()
uniqnessFA <- c()
loadingsFA <- c()
for(i in uneek){
# makes the sub group for each
subCat <- filter(data,get(colNam) == i)
# extracts the cols we are looking at
subMatrix <- subCat[,colls]
FA <- fa(subMatrix, nfactors = 1,
fm = "pa", max.iter = 100,
rotation = "promax")
# % var explained by factor
ss <- colSums(FA$Structure^2)
perVar <- append(perVar,ss/length(FA$communality))
#this makes that spider thing
#fa.diagram(FA, main = i)
#add scores
scores  <- FA$scores
tract   <- cbind(subCat,scores)[,c("FIPS","PA1")]
tractFA <- rbind(tractFA,tract)
#this removes the uniquness for each strata
uniqnessFA <- bind_rows(uniqnessFA, FA$uniquenesses)
loadingsFA <- bind_rows(loadingsFA, FA$loadings[,1])
}
perVal <- cbind(uneek,perVar)
colnames(perVal) <- c(colNam,"Percent_Var")
#retruns percent variation explained
# and returns the FIPS and associated FA for each
uniqnessOfFA <- cbind(uneek,uniqnessFA)
colnames(uniqnessOfFA) <- c(colNam,colnames(uniqnessFA))
#retruns uniquness for each component and the strata
loadingsOfFA <- cbind(uneek,loadingsFA)
colnames(loadingsOfFA) <- c(colNam,colnames(loadingsFA))
#retruns 'loadings' for each component and the strata
return(list(percentVal = perVal,Strat_FA = tractFA, uniqness_by_var = uniqnessOfFA, loadings_by_var = loadingsOfFA))
}
Histo_By_Strat <- function(data,colNam,colOrig,colStrat){
#this makes a histogram comparing 2 columns of your choosing
# called "colOrig", and "colStrat"
#and are stratified by "colNam"
uneek <- unique(data[[colNam]])  #creates list to iterate thru
for(i in uneek){
par(mfrow = c(1,2))
subCat <- filter(data,get(colNam) == i)
#extracts the 2 colums you wanted histograms of
histOrg <- subCat[,colOrig]
histStrat <- subCat[,colStrat]
hist(histOrg, col=rgb(0,0,1,0.2), main = i)
hist(histStrat, col=rgb(1,0,0,0.2), add=TRUE)
#legends never die
legend('topright', c(colOrig, colStrat),
fill=c(rgb(0,0,1,0.2), rgb(1,0,0,0.2)))
pectSame <- c()
for(j in seq(from=5, to=100, by=5)){
pct <- top_Precentage(subCat,colOrig,colStrat,j)
pectSame <- rbind(pectSame,pct)
}
#this makes plot of how much overlap using counts starting at the top
top_cownt(subCat,colOrig,colStrat)
#makes scatter plor of the two columes scaled from 0->1
#and fits trend line and reference line
print(ggplot(subCat, aes(scale0_1(subCat[,colOrig]), scale0_1(subCat[,colStrat]))) +
geom_point(shape=18, color="blue") +
geom_abline(intercept = 0, slope = 1, color="green") +
geom_smooth(method=lm, se=T, color="darkred", fill="black") + #add linear trend line and Std error
ggtitle(paste(i, colOrig, "x", colStrat)) + # for the main title
xlab(colOrig) + # for the x axis label
ylab(colStrat)) # for the y axis label
}
}
top_Precentage <- function(data,colOrig,colStrat,perct){
nrw <- ceiling(nrow(data)*perct/100)
topOrg <- data %>% arrange(desc(get(colOrig)))  %>% slice(1:nrw) %>% select(FIPS)
topStr <- data %>% arrange(desc(get(colStrat))) %>% slice(1:nrw) %>% select(FIPS)
pctsame <- sum(topStr[,1] %in% topOrg[,1])/nrow(topStr)
return(data.frame(perct,pctsame))
}
top_cownt <- function(data,colOrig,colStrat){
#makes a histogram with points every 100 data points
cowntSame <- c()
samect <- c()
for(i in seq(from=5, nrow(data), by=100)){
nrw <- ceiling(i) #finds max
#selects top amount
topOrg <- data %>% arrange(desc(get(colOrig)))  %>% slice(1:nrw) %>% select(FIPS)
topStr <- data %>% arrange(desc(get(colStrat))) %>% slice(1:nrw) %>% select(FIPS)
#compares Fips from each to see the overlap
samect <- sum(topStr[,1] %in% topOrg[,1])/nrow(topStr)
cowntSame <- rbind(cowntSame,samect)
}
plot(cowntSame,type = "o", col = "#69b3a2", ylab = "Percent Shared", main = "Percent Shared")
}
#scales from 0-1
scale0_1 <- function(x){(x-min(x))/(max(x)-min(x))}
#does analysis stratified and adds it onto the end of the dataframe
strat <- "STATE" #sets strata
byLine <- FA_By_Component(cdcUnik, strat,5:21) #does analysis
withStrata <- left_join(cdcFAtract, byLine$Strat_FA, by="FIPS") #adds FA to big dataframe
#adds name of strata to the last column
names(withStrata)[length(names(withStrata))] <- paste(strat,"PA1",sep = "_")
# makes pretty pictures for each strata identified
#Histo_By_Strat(withStrata,"STATE","FULL_PA1","STATE_PA1") #compares state to country FA
Histo_By_Strat(withStrata, "STATE", "RPL_THEMES", "STATE_PA1") #compares state FA to CDC country wide
FA <- fa(cdcUnik[,5:21], nfactors = 1, fm = "pa", max.iter = 100, rotation = "promax")
# Transform the matrix in long format
loadngs <- melt(FA$loadings[,1])
colnames(loadngs) <- c("load")
loadngs$rowss <- colnames(cdcUnik[,5:21])
#plots out
ggplot(loadngs, aes(x = 1, y = rowss, fill = load)) +
geom_tile() +
coord_flip() + labs(x = "Loadings", y =  "Parameters from Census") +
theme(axis.text.y = element_text(size = 4),axis.text.x = element_text(angle = 45,  hjust=1)) +
scale_fill_gradient(low = "white", high = "red") +
scale_y_discrete(labels = c("Total Population","Below 150 of Poverty","Unemployed","Housing Cost Burden","No Highschool Diploma","Uninsured","Over 65","Under 17","Diabled","Single Parent Household","English Proficiency","Minority","Multi-Unit Home","Mobile Home","Crowding Levels","No Vehicle","Group Quarters"))
# Transform the matrix in long format
loadngs <- melt(FA$uniquenesses)
colnames(loadngs) <- c("load")
loadngs$rowss <- colnames(cdcUnik[,5:21])
#plots out
ggplot(loadngs, aes(x = 1, y = rowss, fill = load)) +
geom_tile() +
coord_flip() + labs(x = "Uniquness", y =  "Parameters from Census") +
theme(axis.text.y = element_text(size = 4),axis.text.x = element_text(angle = 45,  hjust=1)) +
scale_fill_gradient(low = "white", high = "blue") +
scale_y_discrete(labels = c("Total Population","Below 150 of Poverty","Unemployed","Housing Cost Burden","No Highschool Diploma","Uninsured","Over 65","Under 17","Diabled","Single Parent Household","English Proficiency","Minority","Multi-Unit Home","Mobile Home","Crowding Levels","No Vehicle","Group Quarters"))
# Transform the matrix in long format
df <- melt(byLine$uniqness_by_var)
colnames(df) <- c("state", "cols", "value")
#plots out
ggplot(df, aes(x = state, y = cols, fill = value)) +
geom_tile() +
coord_flip() + labs(x = "States", y =  "Parameters from Census") +
theme(axis.text.y = element_text(size = 4),axis.text.x = element_text(angle = 45,  hjust=1)) +
scale_fill_gradient(low = "blue", high = "white") +
scale_y_discrete(labels = c("Total Population","Below 150 of Poverty","Unemployed","Housing Cost Burden","No Highschool Diploma","Uninsured","Over 65","Under 17","Diabled","Single Parent Household","English Proficiency","Minority","Multi-Unit Home","Mobile Home","Crowding Levels","No Vehicle","Group Quarters"))
# Transform the matrix in long format
df <- melt(byLine$loadings_by_var)
colnames(df) <- c("state", "cols", "value")
#plots out
ggplot(df, aes(x = state, y = cols, fill = value)) +
geom_tile() +
coord_flip() + labs(x = "States", y =  "Parameters from Census") +
theme(axis.text.y = element_text(size = 4),axis.text.x = element_text(angle = 45,  hjust=1)) +
scale_fill_gradient(low = "white", high = "red") +
scale_y_discrete(labels = c("Total Population","Below 150 of Poverty","Unemployed","Housing Cost Burden","No Highschool Diploma","Uninsured","Over 65","Under 17","Diabled","Single Parent Household","English Proficiency","Minority","Multi-Unit Home","Mobile Home","Crowding Levels","No Vehicle","Group Quarters"))
#this compares the national level FA vs the CDC SIV
ggplot(withStrata, aes(x=rank(RPL_THEMES), y=rank(FULL_PA1))) +
geom_point(shape=18, color="lightgreen") +
geom_abline(intercept = 0, slope = 1, color="red") +
geom_smooth(method=lm, se=T, color="blue4", fill="black") +
ggtitle(paste("CDC SVI Ranks x national FA Ranks")) +
xlab(paste("CDC SVI complete")) + # for the x axis label
ylab(paste("National FA complete")) # for the y axis label
#this compares the stratified state level FA vs the CDC SIV rankings
stratStateRank <- c()
for(i in unique(withStrata$STATE)){
subCat <- filter(withStrata,withStrata$STATE == i)
x <- rank(subCat$RPL_THEMES)
y <- rank(subCat$STATE_PA1)
stratStateRank <- as.data.frame(rbind(stratStateRank, cbind(x,y)))
}
ggplot(stratStateRank, aes(x=x, y= y)) +
geom_point(shape=18, color="lightgreen") +
geom_abline(intercept = 0, slope = 1, color="red") +
geom_smooth(method=lm, se=T, color="blue4", fill="black") +
ggtitle(paste("CDC SVI Ranks x State FA Ranks stratified by state")) +
xlab(paste("CDC SVI Rank")) + # for the x axis label
ylab(paste("STATE FA Rank")) # for the y axis label
uneek <- unique(withStrata[["STATE"]])  #creates list to iterate thru
plott <- c()
corTable <- c()
for(i in uneek){
subCat <- filter(withStrata,get("STATE") == i)
spearCor <- cor.test(x=rank(subCat$RPL_THEMES), y=rank(subCat$STATE_PA1), method = 'spearman')
corTable <- rbind(corTable, c(state = i, Estimate = spearCor$estimate, Pvalue = spearCor$p.value))
print(ggplot(subCat, aes(x=rank(subCat$RPL_THEMES), y=rank(subCat$STATE_PA1))) +
geom_point(shape=18, color="lightgreen") +
geom_abline(intercept = 0, slope = 1, color="green") +
geom_smooth(method=lm, se=T, color="blue4", fill="black") +
ggtitle(paste(i, "CDC SVI Ranks x State FA Ranks")) +
xlab(paste("CDC SVI ", i)) + # for the x axis label
ylab(paste("STATE FA ", i))) # for the y axis label
}
#need to clean this up?? wrong col names
corTable <- as.data.frame(corTable)
#create %overlap for each state
perct <- 0.15
region <- c()
pct <- c()
pctSharedbyState <- c()
for(i in unique(withStrata$STATE)){
subCat <- filter(withStrata,get("STATE") == i)
lngth <- nrow(subCat) * perct
#selects top amount
topOrg <- subCat %>% arrange(desc(get("RPL_THEMES")))  %>% slice(1:lngth) %>% select(FIPS)
topStr <- subCat %>% arrange(desc(get("STATE_PA1"))) %>% slice(1:lngth) %>% select(FIPS)
#compares Fips from each to see the overlap
samect <- round(sum(topStr[,1] %in% topOrg[,1])/nrow(topStr), 3)
region <- rbind(region, i)
pct <- rbind(pct, samect)
}
pctSharedbyState <- cbind.data.frame(region =region,pct = pct)
states <- map_data("state")
colnames(pctSharedbyState) <- c("region","pct")
pctSharedbyState$region <- tolower(pctSharedbyState$region)
shared.geo <- merge(states,pctSharedbyState,by = "region")
shared.geo <- shared.geo[order(shared.geo$order),]
ggplot(shared.geo,aes(long, lat))+
geom_polygon(aes(group=group, fill= pct))+
coord_map() + scale_fill_gradient2(
low = "yellow",
mid = "green",
high = "blue",
midpoint = 0.5)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
#create %overlap for each state
perct <- 0.10
region <- c()
pct <- c()
pctSharedbyState <- c()
for(i in unique(withStrata$STATE)){
subCat <- filter(withStrata,get("STATE") == i)
lngth <- nrow(subCat) * perct
#selects top amount
topOrg <- subCat %>% arrange(desc(get("RPL_THEMES")))  %>% slice(1:lngth) %>% select(FIPS)
topStr <- subCat %>% arrange(desc(get("STATE_PA1"))) %>% slice(1:lngth) %>% select(FIPS)
#compares Fips from each to see the overlap
samect <- round(sum(topStr[,1] %in% topOrg[,1])/nrow(topStr), 3)
region <- rbind(region, i)
pct <- rbind(pct, samect)
}
pctSharedbyState <- cbind.data.frame(region =region,pct = pct)
states <- map_data("state")
colnames(pctSharedbyState) <- c("region","pct")
pctSharedbyState$region <- tolower(pctSharedbyState$region)
shared.geo <- merge(states,pctSharedbyState,by = "region")
shared.geo <- shared.geo[order(shared.geo$order),]
ggplot(shared.geo,aes(long, lat))+
geom_polygon(aes(group=group, fill= pct))+
coord_map() + scale_fill_gradient2(
low = "yellow",
mid = "green",
high = "blue",
midpoint = 0.5)
#create %overlap for each state
perct <- 0.05
region <- c()
pct <- c()
pctSharedbyState <- c()
for(i in unique(withStrata$STATE)){
subCat <- filter(withStrata,get("STATE") == i)
lngth <- nrow(subCat) * perct
#selects top amount
topOrg <- subCat %>% arrange(desc(get("RPL_THEMES")))  %>% slice(1:lngth) %>% select(FIPS)
topStr <- subCat %>% arrange(desc(get("STATE_PA1"))) %>% slice(1:lngth) %>% select(FIPS)
#compares Fips from each to see the overlap
samect <- round(sum(topStr[,1] %in% topOrg[,1])/nrow(topStr), 3)
region <- rbind(region, i)
pct <- rbind(pct, samect)
}
pctSharedbyState <- cbind.data.frame(region =region,pct = pct)
states <- map_data("state")
colnames(pctSharedbyState) <- c("region","pct")
pctSharedbyState$region <- tolower(pctSharedbyState$region)
shared.geo <- merge(states,pctSharedbyState,by = "region")
shared.geo <- shared.geo[order(shared.geo$order),]
ggplot(shared.geo,aes(long, lat))+
geom_polygon(aes(group=group, fill= pct))+
coord_map() + scale_fill_gradient2(
low = "yellow",
mid = "green",
high = "blue",
midpoint = 0.5)
